{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport BigNumber from 'bignumber.js/bignumber';\nimport ERC20Abi from './abi/erc20.json';\nimport MasterChefAbi from './abi/masterchef.json';\nimport XSushiAbi from './abi/xsushi.json';\nimport SushiAbi from './abi/sushi.json';\nimport UNIV2PairAbi from './abi/uni_v2_lp.json';\nimport WETHAbi from './abi/weth.json';\nimport { contractAddresses, SUBTRACT_GAS_LIMIT, supportedPools } from './constants.js';\nimport * as Types from './types.js';\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3;\n    this.defaultConfirmations = options.defaultConfirmations;\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5;\n    this.confirmationType = options.confirmationType || Types.ConfirmationType.Confirmed;\n    this.defaultGas = options.defaultGas;\n    this.defaultGasPrice = options.defaultGasPrice;\n    this.sushi = new this.web3.eth.Contract(SushiAbi);\n    this.masterChef = new this.web3.eth.Contract(MasterChefAbi);\n    this.xSushiStaking = new this.web3.eth.Contract(XSushiAbi);\n    this.weth = new this.web3.eth.Contract(WETHAbi);\n    this.pools = supportedPools.map(pool => Object.assign(pool, {\n      lpAddress: pool.lpAddresses[networkId],\n      tokenAddress: pool.tokenAddresses[networkId],\n      lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n      tokenContract: new this.web3.eth.Contract(ERC20Abi)\n    }));\n    this.setProvider(provider, networkId);\n    this.setDefaultAccount(this.web3.eth.defaultAccount);\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider);\n      if (address) contract.options.address = address;else console.error('Contract address not found in network', networkId);\n    };\n\n    setProvider(this.sushi, contractAddresses.sushi[networkId]);\n    setProvider(this.masterChef, contractAddresses.masterChef[networkId]);\n    setProvider(this.xSushiStaking, contractAddresses.xSushi[networkId]);\n    setProvider(this.weth, contractAddresses.weth[networkId]);\n    this.pools.forEach(({\n      lpContract,\n      lpAddress,\n      tokenContract,\n      tokenAddress\n    }) => {\n      setProvider(lpContract, lpAddress);\n      setProvider(tokenContract, tokenAddress);\n    });\n  }\n\n  setDefaultAccount(account) {\n    this.sushi.options.from = account;\n    this.masterChef.options.from = account;\n  }\n\n  async callContractFunction(method, options) {\n    const {\n      confirmations,\n      confirmationType,\n      autoGasMultiplier\n    } = options,\n          txOptions = _objectWithoutProperties(options, [\"confirmations\", \"confirmationType\", \"autoGasMultiplier\"]);\n\n    if (!this.blockGasLimit) {\n      await this.setGasLimit();\n    }\n\n    if (!txOptions.gasPrice && this.defaultGasPrice) {\n      txOptions.gasPrice = this.defaultGasPrice;\n    }\n\n    if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n      let gasEstimate;\n\n      if (this.defaultGas && confirmationType !== Types.ConfirmationType.Simulate) {\n        txOptions.gas = this.defaultGas;\n      } else {\n        try {\n          console.log('estimating gas');\n          gasEstimate = await method.estimateGas(txOptions);\n        } catch (error) {\n          const data = method.encodeABI();\n          const {\n            from,\n            value\n          } = options;\n          const to = method._parent._address;\n          error.transactionData = {\n            from,\n            value,\n            data,\n            to\n          };\n          throw error;\n        }\n\n        const multiplier = autoGasMultiplier || this.autoGasMultiplier;\n        const totalGas = Math.floor(gasEstimate * multiplier);\n        txOptions.gas = totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit;\n      }\n\n      if (confirmationType === Types.ConfirmationType.Simulate) {\n        let g = txOptions.gas;\n        return {\n          gasEstimate,\n          g\n        };\n      }\n    }\n\n    if (txOptions.value) {\n      txOptions.value = new BigNumber(txOptions.value).toFixed(0);\n    } else {\n      txOptions.value = '0';\n    }\n\n    const promi = method.send(txOptions);\n    const OUTCOMES = {\n      INITIAL: 0,\n      RESOLVED: 1,\n      REJECTED: 2\n    };\n    let hashOutcome = OUTCOMES.INITIAL;\n    let confirmationOutcome = OUTCOMES.INITIAL;\n    const t = confirmationType !== undefined ? confirmationType : this.confirmationType;\n\n    if (!Object.values(Types.ConfirmationType).includes(t)) {\n      throw new Error(`Invalid confirmation type: ${t}`);\n    }\n\n    let hashPromise;\n    let confirmationPromise;\n\n    if (t === Types.ConfirmationType.Hash || t === Types.ConfirmationType.Both) {\n      hashPromise = new Promise((resolve, reject) => {\n        promi.on('error', error => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.REJECTED;\n            reject(error);\n            const anyPromi = promi;\n            anyPromi.off();\n          }\n        });\n        promi.on('transactionHash', txHash => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.RESOLVED;\n            resolve(txHash);\n\n            if (t !== Types.ConfirmationType.Both) {\n              const anyPromi = promi;\n              anyPromi.off();\n            }\n          }\n        });\n      });\n    }\n\n    if (t === Types.ConfirmationType.Confirmed || t === Types.ConfirmationType.Both) {\n      confirmationPromise = new Promise((resolve, reject) => {\n        promi.on('error', error => {\n          if ((t === Types.ConfirmationType.Confirmed || hashOutcome === OUTCOMES.RESOLVED) && confirmationOutcome === OUTCOMES.INITIAL) {\n            confirmationOutcome = OUTCOMES.REJECTED;\n            reject(error);\n            const anyPromi = promi;\n            anyPromi.off();\n          }\n        });\n        const desiredConf = confirmations || this.defaultConfirmations;\n\n        if (desiredConf) {\n          promi.on('confirmation', (confNumber, receipt) => {\n            if (confNumber >= desiredConf) {\n              if (confirmationOutcome === OUTCOMES.INITIAL) {\n                confirmationOutcome = OUTCOMES.RESOLVED;\n                resolve(receipt);\n                const anyPromi = promi;\n                anyPromi.off();\n              }\n            }\n          });\n        } else {\n          promi.on('receipt', receipt => {\n            confirmationOutcome = OUTCOMES.RESOLVED;\n            resolve(receipt);\n            const anyPromi = promi;\n            anyPromi.off();\n          });\n        }\n      });\n    }\n\n    if (t === Types.ConfirmationType.Hash) {\n      const transactionHash = await hashPromise;\n\n      if (this.notifier) {\n        this.notifier.hash(transactionHash);\n      }\n\n      return {\n        transactionHash\n      };\n    }\n\n    if (t === Types.ConfirmationType.Confirmed) {\n      return confirmationPromise;\n    }\n\n    const transactionHash = await hashPromise;\n\n    if (this.notifier) {\n      this.notifier.hash(transactionHash);\n    }\n\n    return {\n      transactionHash,\n      confirmation: confirmationPromise\n    };\n  }\n\n  async callConstantContractFunction(method, options) {\n    const m2 = method;\n\n    const {\n      blockNumber\n    } = options,\n          txOptions = _objectWithoutProperties(options, [\"blockNumber\"]);\n\n    return m2.call(txOptions, blockNumber);\n  }\n\n  async setGasLimit() {\n    const block = await this.web3.eth.getBlock('latest');\n    this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT;\n  }\n\n}","map":{"version":3,"sources":["/Users/theo/genesis/sushi/lib/contracts.js"],"names":["BigNumber","ERC20Abi","MasterChefAbi","XSushiAbi","SushiAbi","UNIV2PairAbi","WETHAbi","contractAddresses","SUBTRACT_GAS_LIMIT","supportedPools","Types","Contracts","constructor","provider","networkId","web3","options","defaultConfirmations","autoGasMultiplier","confirmationType","ConfirmationType","Confirmed","defaultGas","defaultGasPrice","sushi","eth","Contract","masterChef","xSushiStaking","weth","pools","map","pool","Object","assign","lpAddress","lpAddresses","tokenAddress","tokenAddresses","lpContract","tokenContract","setProvider","setDefaultAccount","defaultAccount","contract","address","console","error","xSushi","forEach","account","from","callContractFunction","method","confirmations","txOptions","blockGasLimit","setGasLimit","gasPrice","Simulate","gas","gasEstimate","log","estimateGas","data","encodeABI","value","to","_parent","_address","transactionData","multiplier","totalGas","Math","floor","g","toFixed","promi","send","OUTCOMES","INITIAL","RESOLVED","REJECTED","hashOutcome","confirmationOutcome","t","undefined","values","includes","Error","hashPromise","confirmationPromise","Hash","Both","Promise","resolve","reject","on","anyPromi","off","txHash","desiredConf","confNumber","receipt","transactionHash","notifier","hash","confirmation","callConstantContractFunction","m2","blockNumber","call","block","getBlock","gasLimit"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js/bignumber'\nimport ERC20Abi from './abi/erc20.json'\nimport MasterChefAbi from './abi/masterchef.json'\nimport XSushiAbi from './abi/xsushi.json'\nimport SushiAbi from './abi/sushi.json'\nimport UNIV2PairAbi from './abi/uni_v2_lp.json'\nimport WETHAbi from './abi/weth.json'\nimport {\n  contractAddresses,\n  SUBTRACT_GAS_LIMIT,\n  supportedPools,\n} from './constants.js'\nimport * as Types from './types.js'\n\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3\n    this.defaultConfirmations = options.defaultConfirmations\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5\n    this.confirmationType =\n      options.confirmationType || Types.ConfirmationType.Confirmed\n    this.defaultGas = options.defaultGas\n    this.defaultGasPrice = options.defaultGasPrice\n\n    this.sushi = new this.web3.eth.Contract(SushiAbi)\n    this.masterChef = new this.web3.eth.Contract(MasterChefAbi)\n    this.xSushiStaking = new this.web3.eth.Contract(XSushiAbi)\n    this.weth = new this.web3.eth.Contract(WETHAbi)\n\n    this.pools = supportedPools.map((pool) =>\n      Object.assign(pool, {\n        lpAddress: pool.lpAddresses[networkId],\n        tokenAddress: pool.tokenAddresses[networkId],\n        lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n        tokenContract: new this.web3.eth.Contract(ERC20Abi),\n      }),\n    )\n\n    this.setProvider(provider, networkId)\n    this.setDefaultAccount(this.web3.eth.defaultAccount)\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider)\n      if (address) contract.options.address = address\n      else console.error('Contract address not found in network', networkId)\n    }\n\n    setProvider(this.sushi, contractAddresses.sushi[networkId])\n    setProvider(this.masterChef, contractAddresses.masterChef[networkId])\n    setProvider(this.xSushiStaking, contractAddresses.xSushi[networkId])\n    setProvider(this.weth, contractAddresses.weth[networkId])\n\n    this.pools.forEach(\n      ({ lpContract, lpAddress, tokenContract, tokenAddress }) => {\n        setProvider(lpContract, lpAddress)\n        setProvider(tokenContract, tokenAddress)\n      },\n    )\n  }\n\n  setDefaultAccount(account) {\n    this.sushi.options.from = account\n    this.masterChef.options.from = account\n  }\n\n  async callContractFunction(method, options) {\n    const {\n      confirmations,\n      confirmationType,\n      autoGasMultiplier,\n      ...txOptions\n    } = options\n\n    if (!this.blockGasLimit) {\n      await this.setGasLimit()\n    }\n\n    if (!txOptions.gasPrice && this.defaultGasPrice) {\n      txOptions.gasPrice = this.defaultGasPrice\n    }\n\n    if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n      let gasEstimate\n      if (\n        this.defaultGas &&\n        confirmationType !== Types.ConfirmationType.Simulate\n      ) {\n        txOptions.gas = this.defaultGas\n      } else {\n        try {\n          console.log('estimating gas')\n          gasEstimate = await method.estimateGas(txOptions)\n        } catch (error) {\n          const data = method.encodeABI()\n          const { from, value } = options\n          const to = method._parent._address\n          error.transactionData = { from, value, data, to }\n          throw error\n        }\n\n        const multiplier = autoGasMultiplier || this.autoGasMultiplier\n        const totalGas = Math.floor(gasEstimate * multiplier)\n        txOptions.gas =\n          totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit\n      }\n\n      if (confirmationType === Types.ConfirmationType.Simulate) {\n        let g = txOptions.gas\n        return { gasEstimate, g }\n      }\n    }\n\n    if (txOptions.value) {\n      txOptions.value = new BigNumber(txOptions.value).toFixed(0)\n    } else {\n      txOptions.value = '0'\n    }\n\n    const promi = method.send(txOptions)\n\n    const OUTCOMES = {\n      INITIAL: 0,\n      RESOLVED: 1,\n      REJECTED: 2,\n    }\n\n    let hashOutcome = OUTCOMES.INITIAL\n    let confirmationOutcome = OUTCOMES.INITIAL\n\n    const t =\n      confirmationType !== undefined ? confirmationType : this.confirmationType\n\n    if (!Object.values(Types.ConfirmationType).includes(t)) {\n      throw new Error(`Invalid confirmation type: ${t}`)\n    }\n\n    let hashPromise\n    let confirmationPromise\n\n    if (\n      t === Types.ConfirmationType.Hash ||\n      t === Types.ConfirmationType.Both\n    ) {\n      hashPromise = new Promise((resolve, reject) => {\n        promi.on('error', (error) => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.REJECTED\n            reject(error)\n            const anyPromi = promi\n            anyPromi.off()\n          }\n        })\n\n        promi.on('transactionHash', (txHash) => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.RESOLVED\n            resolve(txHash)\n            if (t !== Types.ConfirmationType.Both) {\n              const anyPromi = promi\n              anyPromi.off()\n            }\n          }\n        })\n      })\n    }\n\n    if (\n      t === Types.ConfirmationType.Confirmed ||\n      t === Types.ConfirmationType.Both\n    ) {\n      confirmationPromise = new Promise((resolve, reject) => {\n        promi.on('error', (error) => {\n          if (\n            (t === Types.ConfirmationType.Confirmed ||\n              hashOutcome === OUTCOMES.RESOLVED) &&\n            confirmationOutcome === OUTCOMES.INITIAL\n          ) {\n            confirmationOutcome = OUTCOMES.REJECTED\n            reject(error)\n            const anyPromi = promi\n            anyPromi.off()\n          }\n        })\n\n        const desiredConf = confirmations || this.defaultConfirmations\n        if (desiredConf) {\n          promi.on('confirmation', (confNumber, receipt) => {\n            if (confNumber >= desiredConf) {\n              if (confirmationOutcome === OUTCOMES.INITIAL) {\n                confirmationOutcome = OUTCOMES.RESOLVED\n                resolve(receipt)\n                const anyPromi = promi\n                anyPromi.off()\n              }\n            }\n          })\n        } else {\n          promi.on('receipt', (receipt) => {\n            confirmationOutcome = OUTCOMES.RESOLVED\n            resolve(receipt)\n            const anyPromi = promi\n            anyPromi.off()\n          })\n        }\n      })\n    }\n\n    if (t === Types.ConfirmationType.Hash) {\n      const transactionHash = await hashPromise\n      if (this.notifier) {\n        this.notifier.hash(transactionHash)\n      }\n      return { transactionHash }\n    }\n\n    if (t === Types.ConfirmationType.Confirmed) {\n      return confirmationPromise\n    }\n\n    const transactionHash = await hashPromise\n    if (this.notifier) {\n      this.notifier.hash(transactionHash)\n    }\n    return {\n      transactionHash,\n      confirmation: confirmationPromise,\n    }\n  }\n\n  async callConstantContractFunction(method, options) {\n    const m2 = method\n    const { blockNumber, ...txOptions } = options\n    return m2.call(txOptions, blockNumber)\n  }\n\n  async setGasLimit() {\n    const block = await this.web3.eth.getBlock('latest')\n    this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT\n  }\n}\n"]},"metadata":{},"sourceType":"module"}