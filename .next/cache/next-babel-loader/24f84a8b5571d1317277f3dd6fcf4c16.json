{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\n/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\nvar REQUIRE_MSG = 'Returned error: VM Exception while processing transaction: revert';\nvar ASSERT_MSG = 'Returned error: VM Exception while processing transaction: invalid opcode';\nexport var EVM = /*#__PURE__*/function () {\n  function EVM(provider) {\n    _classCallCheck(this, EVM);\n\n    this.provider = provider;\n  }\n\n  _createClass(EVM, [{\n    key: \"setProvider\",\n    value: function setProvider(provider) {\n      this.provider = provider;\n    }\n    /**\n     * Attempts to reset the EVM to its initial state. Useful for testing suites\n     *\n     * @param provider a valid web3 provider\n     * @returns null\n     */\n\n  }, {\n    key: \"resetEVM\",\n    value: function () {\n      var _resetEVM = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var resetSnapshotId,\n            id,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                resetSnapshotId = _args.length > 0 && _args[0] !== undefined ? _args[0] : '0x1';\n                _context.next = 3;\n                return this.snapshot();\n\n              case 3:\n                id = _context.sent;\n\n                if (!(id !== resetSnapshotId)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 7;\n                return this.reset(resetSnapshotId);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function resetEVM() {\n        return _resetEVM.apply(this, arguments);\n      }\n\n      return resetEVM;\n    }()\n  }, {\n    key: \"reset\",\n    value: function () {\n      var _reset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (id) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('id must be set');\n\n              case 2:\n                _context2.next = 4;\n                return this.callJsonrpcMethod('evm_revert', [id]);\n\n              case 4:\n                return _context2.abrupt(\"return\", this.snapshot());\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function reset(_x) {\n        return _reset.apply(this, arguments);\n      }\n\n      return reset;\n    }()\n  }, {\n    key: \"snapshot\",\n    value: function () {\n      var _snapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.callJsonrpcMethod('evm_snapshot'));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function snapshot() {\n        return _snapshot.apply(this, arguments);\n      }\n\n      return snapshot;\n    }()\n  }, {\n    key: \"evmRevert\",\n    value: function () {\n      var _evmRevert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.callJsonrpcMethod('evm_revert', [id]));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function evmRevert(_x2) {\n        return _evmRevert.apply(this, arguments);\n      }\n\n      return evmRevert;\n    }()\n  }, {\n    key: \"stopMining\",\n    value: function () {\n      var _stopMining = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.callJsonrpcMethod('miner_stop'));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function stopMining() {\n        return _stopMining.apply(this, arguments);\n      }\n\n      return stopMining;\n    }()\n  }, {\n    key: \"startMining\",\n    value: function () {\n      var _startMining = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.callJsonrpcMethod('miner_start'));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function startMining() {\n        return _startMining.apply(this, arguments);\n      }\n\n      return startMining;\n    }()\n  }, {\n    key: \"mineBlock\",\n    value: function () {\n      var _mineBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", this.callJsonrpcMethod('evm_mine'));\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function mineBlock() {\n        return _mineBlock.apply(this, arguments);\n      }\n\n      return mineBlock;\n    }()\n  }, {\n    key: \"increaseTime\",\n    value: function () {\n      var _increaseTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(duration) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this.callJsonrpcMethod('evm_increaseTime', [duration]));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function increaseTime(_x3) {\n        return _increaseTime.apply(this, arguments);\n      }\n\n      return increaseTime;\n    }()\n  }, {\n    key: \"callJsonrpcMethod\",\n    value: function () {\n      var _callJsonrpcMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(method, params) {\n        var args, response;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                args = {\n                  method: method,\n                  params: params,\n                  jsonrpc: '2.0',\n                  id: new Date().getTime()\n                };\n                _context9.next = 3;\n                return this.send(args);\n\n              case 3:\n                response = _context9.sent;\n                return _context9.abrupt(\"return\", response.result);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function callJsonrpcMethod(_x4, _x5) {\n        return _callJsonrpcMethod.apply(this, arguments);\n      }\n\n      return callJsonrpcMethod;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(args) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var callback = function callback(error, val) {\n                    if (error) {\n                      reject(error);\n                    } else {\n                      resolve(val);\n                    }\n                  };\n\n                  _this.provider.send(args, callback);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function send(_x6) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }() // Helper function\n\n  }, {\n    key: \"assertCertainError\",\n    value: function assertCertainError(error, expected_error_msg) {\n      // This complication is so that the actual error will appear in truffle test output\n      var message = error.message;\n      var matchedIndex = message.search(expected_error_msg);\n      var matchedString = message;\n\n      if (matchedIndex === 0) {\n        matchedString = message.substring(matchedIndex, matchedIndex + expected_error_msg.length);\n      }\n\n      expect(matchedString).toEqual(expected_error_msg);\n    } // For solidity function calls that violate require()\n\n  }, {\n    key: \"expectThrow\",\n    value: function () {\n      var _expectThrow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(promise, reason) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                _context11.next = 3;\n                return promise;\n\n              case 3:\n                throw new Error('Did not throw');\n\n              case 6:\n                _context11.prev = 6;\n                _context11.t0 = _context11[\"catch\"](0);\n                this.assertCertainError(_context11.t0, REQUIRE_MSG);\n\n                if (reason && process.env.COVERAGE !== 'true') {\n                  this.assertCertainError(_context11.t0, \"\".concat(REQUIRE_MSG, \" \").concat(reason));\n                }\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 6]]);\n      }));\n\n      function expectThrow(_x7, _x8) {\n        return _expectThrow.apply(this, arguments);\n      }\n\n      return expectThrow;\n    }() // For solidity function calls that violate assert()\n\n  }, {\n    key: \"expectAssertFailure\",\n    value: function () {\n      var _expectAssertFailure = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(promise) {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return promise;\n\n              case 3:\n                throw new Error('Did not throw');\n\n              case 6:\n                _context12.prev = 6;\n                _context12.t0 = _context12[\"catch\"](0);\n                this.assertCertainError(_context12.t0, ASSERT_MSG);\n\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 6]]);\n      }));\n\n      function expectAssertFailure(_x9) {\n        return _expectAssertFailure.apply(this, arguments);\n      }\n\n      return expectAssertFailure;\n    }()\n  }]);\n\n  return EVM;\n}();","map":{"version":3,"sources":["/Users/theo/genesis/sushi/lib/evm.js"],"names":["REQUIRE_MSG","ASSERT_MSG","EVM","provider","resetSnapshotId","snapshot","id","reset","Error","callJsonrpcMethod","duration","method","params","args","jsonrpc","Date","getTime","send","response","result","Promise","resolve","reject","callback","error","val","expected_error_msg","message","matchedIndex","search","matchedString","substring","length","expect","toEqual","promise","reason","assertCertainError","process","env","COVERAGE"],"mappings":"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","sourcesContent":["/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\n\nconst REQUIRE_MSG = 'Returned error: VM Exception while processing transaction: revert';\nconst ASSERT_MSG = 'Returned error: VM Exception while processing transaction: invalid opcode';\n\nexport class EVM {\n  constructor(\n    provider,\n  ) {\n    this.provider = provider;\n  }\n\n  setProvider(\n    provider,\n  ){\n    this.provider = provider;\n  }\n\n  /**\n   * Attempts to reset the EVM to its initial state. Useful for testing suites\n   *\n   * @param provider a valid web3 provider\n   * @returns null\n   */\n   async resetEVM(resetSnapshotId = '0x1') {\n    const id = await this.snapshot();\n\n    if (id !== resetSnapshotId) {\n      await this.reset(resetSnapshotId);\n    }\n  }\n\n   async reset(id) {\n    if (!id) {\n      throw new Error('id must be set');\n    }\n\n    await this.callJsonrpcMethod('evm_revert', [id]);\n\n    return this.snapshot();\n  }\n\n   async snapshot() {\n    return this.callJsonrpcMethod('evm_snapshot');\n  }\n\n   async evmRevert(id) {\n    return this.callJsonrpcMethod('evm_revert', [id]);\n  }\n\n   async stopMining() {\n    return this.callJsonrpcMethod('miner_stop');\n  }\n\n   async startMining() {\n    return this.callJsonrpcMethod('miner_start');\n  }\n\n   async mineBlock() {\n    return this.callJsonrpcMethod('evm_mine');\n  }\n\n   async increaseTime(duration) {\n    return this.callJsonrpcMethod('evm_increaseTime', [duration]);\n  }\n\n   async callJsonrpcMethod(method, params) {\n    const args= {\n      method,\n      params,\n      jsonrpc: '2.0',\n      id: new Date().getTime(),\n    };\n\n    const response = await this.send(args);\n\n    return response.result;\n  }\n\n   async send(args) {\n    return new Promise((resolve, reject) => {\n      const callback = (error, val)=> {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(val);\n        }\n      };\n\n      this.provider.send(\n        args,\n        callback,\n      );\n    });\n  }\n\n  // Helper function\n  assertCertainError(error, expected_error_msg) {\n    // This complication is so that the actual error will appear in truffle test output\n    const message = error.message;\n    const matchedIndex = message.search(expected_error_msg);\n    let matchedString = message;\n    if (matchedIndex === 0) {\n      matchedString = message.substring(matchedIndex, matchedIndex + expected_error_msg.length);\n    }\n    expect(matchedString).toEqual(expected_error_msg);\n  }\n\n  // For solidity function calls that violate require()\n  async expectThrow(promise, reason) {\n    try {\n      await promise;\n      throw new Error('Did not throw');\n    } catch (e) {\n      this.assertCertainError(e, REQUIRE_MSG);\n      if (reason && process.env.COVERAGE !== 'true') {\n        this.assertCertainError(e, `${REQUIRE_MSG} ${reason}`);\n      }\n    }\n  }\n\n  // For solidity function calls that violate assert()\n  async expectAssertFailure(promise) {\n    try {\n      await promise;\n      throw new Error('Did not throw');\n    } catch (e) {\n      this.assertCertainError(e, ASSERT_MSG);\n    }\n  }\n\n\n\n}\n"]},"metadata":{},"sourceType":"module"}